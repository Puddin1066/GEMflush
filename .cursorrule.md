# Cursor Rules for SaaS Starter Project

## Core Programming Principles

### DRY (Don't Repeat Yourself)
- **Never duplicate code**: Extract reusable logic into functions, components, or utilities
- **Single source of truth**: Maintain one canonical source for each piece of knowledge
- **Shared utilities**: Create helper functions in `/lib` for common operations
- **Component reusability**: Build generic, configurable components rather than duplicating similar ones
- **Database queries**: Centralize database queries in `/lib/db/queries.ts`

### SOLID Principles

#### Single Responsibility Principle (SRP)
- Each function, component, or module should have ONE clear purpose
- Separate concerns: UI components should not contain business logic
- Keep API routes focused on a single resource or action

#### Open/Closed Principle (OCP)
- Code should be open for extension, closed for modification
- Use composition and configuration over modification
- Leverage TypeScript interfaces and type unions for extensibility

#### Liskov Substitution Principle (LSP)
- Subtypes must be substitutable for their base types
- Maintain consistent interfaces and contracts
- Ensure derived components honor parent component contracts

#### Interface Segregation Principle (ISP)
- No client should depend on interfaces it doesn't use
- Create focused, minimal interfaces
- Split large type definitions into smaller, specific ones

#### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concrete implementations
- Use dependency injection patterns where appropriate
- Abstract external services (Stripe, database) behind interfaces

## Project-Specific Conventions

### File and Folder Structure
- Use kebab-case for file names: `submit-button.tsx`, not `SubmitButton.tsx`
- Group related functionality in directories
- Colocate related files (components, styles, tests)
- Place shared components in `/components`
- Place utilities in `/lib`

### TypeScript Standards
- **Always use TypeScript**: No `.js` or `.jsx` files
- **Strict typing**: Enable strict mode, avoid `any` type
- **Type definitions**: Define interfaces for all data structures
- **Type exports**: Export types alongside implementations
- **Null safety**: Use optional chaining and nullish coalescing

```typescript
// Good
interface User {
  id: string;
  email: string;
  name: string | null;
}

// Bad
const user: any = getUserData();
```

### React and Next.js Best Practices
- **Server Components by default**: Use Client Components only when needed
- **Use `'use client'` directive**: Only when using hooks, event handlers, or browser APIs
- **Async Server Components**: Fetch data directly in Server Components
- **Error boundaries**: Implement error handling with `error.tsx`
- **Loading states**: Provide loading.tsx for better UX
- **Metadata**: Define metadata for SEO in each page

### Component Guidelines
- **Functional components only**: No class components
- **Props interface**: Always define props with TypeScript interfaces
- **Component composition**: Prefer composition over prop drilling
- **Keep components small**: Max 200-300 lines per component
- **Extract complex logic**: Use custom hooks or utility functions

```typescript
// Good
interface ButtonProps {
  variant: 'primary' | 'secondary';
  onClick: () => void;
  children: React.ReactNode;
}

export function Button({ variant, onClick, children }: ButtonProps) {
  return <button className={`btn-${variant}`} onClick={onClick}>{children}</button>;
}
```

### State Management
- **Server state in URL**: Use searchParams for filters, pagination
- **Client state**: Use React hooks (useState, useReducer)
- **Form state**: Leverage Server Actions with native FormData
- **Minimize client state**: Keep state close to where it's used

### Database and ORM (Drizzle)
- **Use schema definitions**: All tables defined in `/lib/db/schema.ts`
- **Type-safe queries**: Leverage Drizzle's TypeScript support
- **Centralized queries**: Keep queries in `/lib/db/queries.ts`
- **Migrations**: Always use migrations, never manually modify schema
- **Transactions**: Use database transactions for multi-step operations

```typescript
// Good - Centralized query
export async function getUserByEmail(email: string) {
  return await db.query.users.findFirst({
    where: eq(users.email, email),
  });
}
```

### API Route Standards
- **RESTful conventions**: Use proper HTTP methods (GET, POST, PUT, DELETE)
- **Status codes**: Return appropriate HTTP status codes
- **Error handling**: Implement consistent error responses
- **Validation**: Validate all input data
- **Type safety**: Use TypeScript for request/response types

```typescript
// Good - Proper error handling
export async function POST(request: Request) {
  try {
    const data = await request.json();
    // Validate data
    if (!data.email) {
      return Response.json({ error: 'Email required' }, { status: 400 });
    }
    // Process request
    return Response.json({ success: true }, { status: 200 });
  } catch (error) {
    return Response.json({ error: 'Internal error' }, { status: 500 });
  }
}
```

## Automation and Efficiency

### Leverage Available APIs
- **Stripe API**: Use for all payment operations, subscriptions, and billing
- **Database API (Drizzle)**: Use query builder for type-safe database operations
- **Next.js APIs**: Leverage built-in APIs for routing, data fetching, caching
- **Server Actions**: Use for form submissions and mutations
- **Middleware**: Implement auth, logging, and cross-cutting concerns in middleware

### CLI and Tooling
- **Use npm/pnpm scripts**: Automate common tasks in `package.json`
- **Database migrations**: Use `drizzle-kit` for schema management
- **Code generation**: Generate types, components, or boilerplate with scripts
- **Git hooks**: Automate linting and testing with pre-commit hooks
- **Environment variables**: Use `.env.local` for configuration

```json
// package.json scripts
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "db:push": "drizzle-kit push",
    "db:migrate": "tsx lib/db/setup.ts",
    "db:seed": "tsx lib/db/seed.ts"
  }
}
```

### Automation Best Practices
- **Automate repetitive tasks**: Create scripts for common operations
- **Use migrations**: Never manually update production databases
- **Seed data**: Maintain seed scripts for development/testing
- **Batch operations**: Use bulk operations for efficiency
- **Caching strategies**: Leverage Next.js caching for performance

## CI/CD and Build Process

### Build Process Overview
- **Build command**: `pnpm build` (uses Next.js build with increased memory: `NODE_OPTIONS=--max-old-space-size=4096`)
- **Vercel build**: Uses `vercel-build` script which runs tests before building
- **Build artifacts**: Generated in `.next/` directory
- **Environment**: Node.js 20, pnpm package manager

### GitHub Actions CI/CD Pipeline

#### **Workflow Architecture**
The project uses GitHub Actions as a staging path for Vercel deployments:

```
Push to GitHub
    ↓
GitHub Actions runs quality checks
    ↓
If checks pass → Deploy to Vercel
```

#### **Available Workflows**

**1. Test & Build** (`.github/workflows/test.yml`)
- **Triggers**: Push to `main`/`develop`, PRs to `main`
- **Purpose**: Quality assurance only (no deployment)
- **Steps**:
  - Linting (`pnpm lint`)
  - Type checking (`pnpm tsc --noEmit`)
  - Unit tests (`pnpm test -- --run`)
  - Test coverage generation
  - Build verification (`pnpm build`)

**2. CI/CD - Staging** (`.github/workflows/ci-cd-staging.yml`) ⭐
- **Triggers**: Push to `develop` or `staging` branches
- **Purpose**: Test + Deploy to Vercel Preview/Staging
- **Flow**:
  1. Run all quality checks (lint, type check, tests)
  2. Build application
  3. Deploy to Vercel Preview environment
  4. Provide preview URL for testing
- **Use for**: Testing features before production

**3. CI/CD - Production** (`.github/workflows/ci-cd-production.yml`) ⭐
- **Triggers**: Push to `main` branch, manual workflow_dispatch
- **Purpose**: Test + Deploy to Vercel Production
- **Flow**:
  1. Run all quality checks (lint, type check, tests)
  2. Build application
  3. Deploy to Vercel Production
  4. Provide production URL
- **Use for**: Production deployments

#### **Required GitHub Secrets**
Configure in: Repository Settings → Secrets and variables → Actions

**Required:**
- `VERCEL_TOKEN`: Vercel API token (from https://vercel.com/account/tokens)
- `VERCEL_ORG_ID`: Vercel organization ID
- `VERCEL_PROJECT_ID`: Vercel project ID
- `DATABASE_URL`: PostgreSQL connection string
- `AUTH_SECRET`: Authentication secret (generate with `openssl rand -base64 32`)

**Recommended:**
- `NEXT_PUBLIC_APP_URL`: Application URL
- `STRIPE_SECRET_KEY`: Stripe API key
- `STRIPE_WEBHOOK_SECRET`: Stripe webhook secret
- `RESEND_API_KEY`: Resend email API key
- `OPENROUTER_API_KEY`: OpenRouter API key (if using)

### Deployment Process

#### **Staging Deployment Workflow**

```bash
# 1. Create feature branch
git checkout -b feature/new-feature

# 2. Make changes and commit
git add .
git commit -m "feat: new feature"

# 3. Push to develop for staging deployment
git checkout develop
git merge feature/new-feature
git push origin develop
```

**What happens:**
1. GitHub Actions triggers `ci-cd-staging.yml`
2. Quality checks run (lint, type check, tests)
3. If all pass → Build application
4. Deploy to Vercel Preview (staging)
5. Preview URL provided in GitHub Actions summary

#### **Production Deployment Workflow**

```bash
# 1. Merge staging changes to main
git checkout main
git merge develop
git push origin main
```

**What happens:**
1. GitHub Actions triggers `ci-cd-production.yml`
2. Quality checks run (lint, type check, tests)
3. If all pass → Build application
4. Deploy to Vercel Production
5. Production site updated

#### **Manual Production Deployment**

Can be triggered manually via GitHub Actions UI:
- Go to Actions → CI/CD - Production → Run workflow
- Optionally skip tests (not recommended)

### CI/CD Best Practices

#### **Branch Strategy**
- **`main`**: Production-ready code → Auto-deploys to production
- **`develop`**: Staging-ready code → Auto-deploys to staging
- **`feature/*`**: Feature branches → Test locally, PR to `develop`
- **`fix/*`**: Bug fixes → PR to `develop` or `main` depending on severity

#### **Pre-Deployment Checks**
All deployments require passing:
- ✅ Linting (`pnpm lint`)
- ✅ Type checking (`pnpm tsc --noEmit`)
- ✅ Unit tests (`pnpm test -- --run`)
- ✅ Successful build (`pnpm build`)

**No bypassing**: All checks must pass before deployment

#### **Deployment Safety**
- **Staging first**: Always test in staging before production
- **Test before merge**: Use PRs to trigger CI checks
- **Monitor deployments**: Check GitHub Actions logs and Vercel dashboard
- **Rollback plan**: Keep previous deployments available in Vercel

#### **Environment Variables**
- **Local development**: Use `.env.local` (not committed)
- **GitHub Actions**: Use GitHub Secrets (Repository Settings)
- **Vercel**: Configure in Vercel Dashboard → Settings → Environment Variables
- **Sync**: Keep environment variables consistent across environments

### Build Configuration

#### **Package.json Scripts**

```json
{
  "scripts": {
    "build": "NODE_OPTIONS=--max-old-space-size=4096 next build",
    "vercel-build": "NODE_OPTIONS=--max-old-space-size=4096 next build",
    "lint": "next lint",
    "test": "vitest",
    "test:run": "vitest run"
  }
}
```

#### **Build Process Steps**
1. **Install dependencies**: `pnpm install --frozen-lockfile`
2. **Type check**: `pnpm tsc --noEmit`
3. **Lint**: `pnpm lint`
4. **Test**: `pnpm test -- --run`
5. **Build**: `pnpm build` (Next.js production build)
6. **Deploy**: Vercel deployment (via GitHub Actions)

#### **Build Optimization**
- **Memory allocation**: Increased to 4GB for large builds (`NODE_OPTIONS=--max-old-space-size=4096`)
- **Dependency caching**: GitHub Actions caches pnpm dependencies
- **Build artifacts**: Uploaded for download (main branch only)
- **Incremental builds**: Vercel uses build cache for faster rebuilds

### Documentation
- **Setup Guide**: `docs/deployment/GITHUB_STAGING_DEPLOYMENT.md`
- **Workflow Reference**: `.github/workflows/README.md`
- **Quick Setup**: `GITHUB_ACTIONS_SETUP.md`
- **Setup Script**: `scripts/setup-github-actions.sh`

### Troubleshooting CI/CD

**Build fails in CI but works locally:**
- Check Node.js version (should be 20)
- Verify all environment variables are set in GitHub Secrets
- Check for platform-specific dependencies
- Review build logs for specific errors

**Deployment fails:**
- Verify Vercel credentials (token, org ID, project ID)
- Check Vercel project is linked correctly
- Ensure all required environment variables are in Vercel dashboard
- Review Vercel deployment logs

**Tests fail in CI:**
- Ensure test database URL is set in GitHub Secrets
- Check test environment setup matches local
- Verify all required API keys are in GitHub Secrets
- Review test logs for specific failures

## Code Quality Standards

### Naming Conventions
- **Variables/Functions**: camelCase (`getUserData`, `isValid`)
- **Components**: PascalCase (`UserProfile`, `DashboardLayout`)
- **Constants**: UPPER_SNAKE_CASE (`API_URL`, `MAX_RETRIES`)
- **Private functions**: Prefix with underscore (`_internal`)
- **Boolean variables**: Use `is`, `has`, `should` prefixes (`isLoading`, `hasAccess`)

### Comments and Documentation
- **Self-documenting code**: Write clear code that doesn't need comments
- **Comment WHY, not WHAT**: Explain reasoning, not obvious actions
- **JSDoc for functions**: Document public APIs and complex functions
- **TODO comments**: Include name and date (`// TODO (JJR, 2025-11-09): Fix edge case`)

```typescript
/**
 * Validates user subscription status and returns available features
 * @param userId - The user's unique identifier
 * @returns Object containing subscription tier and enabled features
 * @throws Error if user not found
 */
export async function getUserFeatures(userId: string) {
  // Implementation
}
```

### Error Handling
- **Always handle errors**: Never ignore try-catch blocks
- **Specific error types**: Create custom error classes when needed
- **User-friendly messages**: Show actionable error messages to users
- **Log errors**: Log errors with context for debugging
- **Graceful degradation**: Provide fallbacks when services fail

```typescript
// Good
try {
  await processPayment(data);
} catch (error) {
  console.error('Payment processing failed:', error);
  return { error: 'Unable to process payment. Please try again.' };
}
```

### Performance Considerations
- **Lazy loading**: Use dynamic imports for code splitting
- **Memoization**: Use React.memo, useMemo, useCallback appropriately
- **Database indexing**: Add indexes for frequently queried fields
- **Image optimization**: Use Next.js Image component
- **Bundle size**: Monitor and minimize bundle size

### Security Best Practices
- **Never commit secrets**: Use environment variables for sensitive data
- **Validate all inputs**: Sanitize and validate user input
- **Authentication checks**: Verify auth in API routes and Server Actions
- **SQL injection prevention**: Use parameterized queries (Drizzle handles this)
- **XSS prevention**: Sanitize user-generated content
- **CSRF protection**: Leverage Next.js built-in protections

```typescript
// Good - Environment variables
const stripeKey = process.env.STRIPE_SECRET_KEY;
if (!stripeKey) {
  throw new Error('Missing STRIPE_SECRET_KEY');
}
```

## Testing Guidelines

### Testing Strategy
- **Unit tests**: Test pure functions and utilities
- **Integration tests**: Test API routes and database operations
- **E2E tests**: Test critical user flows
- **Test edge cases**: Include boundary conditions and error scenarios

### E2E Testing Philosophy (Pragmatic Approach)
- **Focus on revenue-generating flows**: Prioritize Pro tier features, subscription upgrades, and core value delivery
- **Test real APIs**: Use real internal APIs; only mock external services (Stripe, Wikidata, LLM APIs)
- **Pragmatic over exhaustive**: Test critical paths that impact business success, not every edge case
- **Pro tier emphasis**: Prioritize testing Pro user journeys where revenue is generated
- **See**: `tests/e2e/PRAGMATIC_KGAAS_TESTS.md` for detailed testing strategy

### E2E Test Structure
- **Use fixtures**: Leverage `tests/e2e/fixtures/authenticated-user.ts` for authenticated sessions
- **Page objects**: Use page objects in `tests/e2e/pages/` for reusable interactions
- **Helpers**: Centralize common operations in `tests/e2e/helpers/`
- **DRY principles**: Reuse fixtures, page objects, and helpers across tests
- **SOLID principles**: Each test file should focus on a single journey/responsibility

### Playwright Test Agents
- **Healer agent**: Use to fix flaky/failing tests automatically (highest value)
- **Planner agent**: Use to generate test plans for missing coverage areas
- **Generator agent**: Use sparingly; prefer manual implementation aligned with existing patterns
- **Seed test**: Maintain `tests/e2e/seed.spec.ts` for agent exploration and environment setup
- **Alignment**: Generated code must align with existing patterns (fixtures, page objects, real APIs)

### Test Organization
- Colocate tests with source files or in `__tests__` directories
- Use descriptive test names: `it('should create user when valid email provided')`
- Follow AAA pattern: Arrange, Act, Assert
- Mock external dependencies only (Stripe, Wikidata, LLM); use real internal APIs

## Git Workflow

### Commit Messages
- Use conventional commits: `feat:`, `fix:`, `chore:`, `docs:`
- Be descriptive: `feat: add user profile editing`
- Reference issues: `fix: resolve payment webhook issue (#123)`

### Branching Strategy (CI/CD Aligned)

**Primary Branches:**
- **`main`**: Production-ready code → Auto-deploys to Vercel Production
- **`develop`**: Staging-ready code → Auto-deploys to Vercel Preview/Staging

**Feature Branches:**
- **`feature/*`**: New features → PR to `develop` for staging deployment
- **`fix/*`**: Bug fixes → PR to `develop` (staging) or `main` (critical)
- **`chore/*`**: Maintenance tasks → PR to `develop`

**Workflow:**
```
feature/new-feature
    ↓ (PR)
develop → Auto-deploy to staging
    ↓ (Merge)
main → Auto-deploy to production
```

### Deployment Flow
- **Staging**: Merge to `develop` → Automatic deployment to Vercel Preview
- **Production**: Merge `develop` to `main` → Automatic deployment to Vercel Production
- **Never deploy directly to production**: Always test in staging first
- **Use PRs**: All changes should go through pull requests for CI checks

## API Usage Patterns

### External Service Integration
- **Abstract services**: Create service wrappers in `/lib`
- **Error handling**: Handle API failures gracefully
- **Rate limiting**: Implement rate limiting for external APIs
- **Caching**: Cache API responses when appropriate
- **Retry logic**: Implement exponential backoff for retries

```typescript
// Good - Service abstraction
export class PaymentService {
  async createCheckout(params: CheckoutParams) {
    try {
      return await stripe.checkout.sessions.create(params);
    } catch (error) {
      console.error('Stripe checkout failed:', error);
      throw new PaymentError('Failed to create checkout session');
    }
  }
}
```

## Final Guidelines

1. **Favor simplicity**: Simple solutions over clever ones
2. **Premature optimization is evil**: Optimize only when needed
3. **Write for humans**: Code is read more than written
4. **Consistency matters**: Follow existing patterns in the codebase
5. **Test critical paths**: Ensure core functionality is tested
6. **Document decisions**: Explain complex or non-obvious choices
7. **Refactor regularly**: Improve code incrementally
8. **Review before committing**: Self-review your changes
9. **Use TypeScript fully**: Leverage the type system
10. **Think about scale**: Consider how code will grow

---

**Remember**: These rules exist to maintain code quality, consistency, and maintainability. When in doubt, prioritize readability and simplicity.

