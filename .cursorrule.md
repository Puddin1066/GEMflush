# Cursor Rules for SaaS Starter Project

## Core Programming Principles

### DRY (Don't Repeat Yourself)
- **Never duplicate code**: Extract reusable logic into functions, components, or utilities
- **Single source of truth**: Maintain one canonical source for each piece of knowledge
- **Shared utilities**: Create helper functions in `/lib` for common operations
- **Component reusability**: Build generic, configurable components rather than duplicating similar ones
- **Database queries**: Centralize database queries in `/lib/db/queries.ts`

### SOLID Principles

#### Single Responsibility Principle (SRP)
- Each function, component, or module should have ONE clear purpose
- Separate concerns: UI components should not contain business logic
- Keep API routes focused on a single resource or action

#### Open/Closed Principle (OCP)
- Code should be open for extension, closed for modification
- Use composition and configuration over modification
- Leverage TypeScript interfaces and type unions for extensibility

#### Liskov Substitution Principle (LSP)
- Subtypes must be substitutable for their base types
- Maintain consistent interfaces and contracts
- Ensure derived components honor parent component contracts

#### Interface Segregation Principle (ISP)
- No client should depend on interfaces it doesn't use
- Create focused, minimal interfaces
- Split large type definitions into smaller, specific ones

#### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concrete implementations
- Use dependency injection patterns where appropriate
- Abstract external services (Stripe, database) behind interfaces

## Project-Specific Conventions

### File and Folder Structure
- Use kebab-case for file names: `submit-button.tsx`, not `SubmitButton.tsx`
- Group related functionality in directories
- Colocate related files (components, styles, tests)
- Place shared components in `/components`
- Place utilities in `/lib`

### TypeScript Standards
- **Always use TypeScript**: No `.js` or `.jsx` files
- **Strict typing**: Enable strict mode, avoid `any` type
- **Type definitions**: Define interfaces for all data structures
- **Type exports**: Export types alongside implementations
- **Null safety**: Use optional chaining and nullish coalescing

```typescript
// Good
interface User {
  id: string;
  email: string;
  name: string | null;
}

// Bad
const user: any = getUserData();
```

### React and Next.js Best Practices
- **Server Components by default**: Use Client Components only when needed
- **Use `'use client'` directive**: Only when using hooks, event handlers, or browser APIs
- **Async Server Components**: Fetch data directly in Server Components
- **Error boundaries**: Implement error handling with `error.tsx`
- **Loading states**: Provide loading.tsx for better UX
- **Metadata**: Define metadata for SEO in each page

### Component Guidelines
- **Functional components only**: No class components
- **Props interface**: Always define props with TypeScript interfaces
- **Component composition**: Prefer composition over prop drilling
- **Keep components small**: Max 200-300 lines per component
- **Extract complex logic**: Use custom hooks or utility functions

```typescript
// Good
interface ButtonProps {
  variant: 'primary' | 'secondary';
  onClick: () => void;
  children: React.ReactNode;
}

export function Button({ variant, onClick, children }: ButtonProps) {
  return <button className={`btn-${variant}`} onClick={onClick}>{children}</button>;
}
```

### State Management
- **Server state in URL**: Use searchParams for filters, pagination
- **Client state**: Use React hooks (useState, useReducer)
- **Form state**: Leverage Server Actions with native FormData
- **Minimize client state**: Keep state close to where it's used

### Database and ORM (Drizzle)
- **Use schema definitions**: All tables defined in `/lib/db/schema.ts`
- **Type-safe queries**: Leverage Drizzle's TypeScript support
- **Centralized queries**: Keep queries in `/lib/db/queries.ts`
- **Migrations**: Always use migrations, never manually modify schema
- **Transactions**: Use database transactions for multi-step operations

```typescript
// Good - Centralized query
export async function getUserByEmail(email: string) {
  return await db.query.users.findFirst({
    where: eq(users.email, email),
  });
}
```

### API Route Standards
- **RESTful conventions**: Use proper HTTP methods (GET, POST, PUT, DELETE)
- **Status codes**: Return appropriate HTTP status codes
- **Error handling**: Implement consistent error responses
- **Validation**: Validate all input data
- **Type safety**: Use TypeScript for request/response types

```typescript
// Good - Proper error handling
export async function POST(request: Request) {
  try {
    const data = await request.json();
    // Validate data
    if (!data.email) {
      return Response.json({ error: 'Email required' }, { status: 400 });
    }
    // Process request
    return Response.json({ success: true }, { status: 200 });
  } catch (error) {
    return Response.json({ error: 'Internal error' }, { status: 500 });
  }
}
```

## Automation and Efficiency

### Leverage Available APIs
- **Stripe API**: Use for all payment operations, subscriptions, and billing
- **Database API (Drizzle)**: Use query builder for type-safe database operations
- **Next.js APIs**: Leverage built-in APIs for routing, data fetching, caching
- **Server Actions**: Use for form submissions and mutations
- **Middleware**: Implement auth, logging, and cross-cutting concerns in middleware

### CLI and Tooling
- **Use npm/pnpm scripts**: Automate common tasks in `package.json`
- **Database migrations**: Use `drizzle-kit` for schema management
- **Code generation**: Generate types, components, or boilerplate with scripts
- **Git hooks**: Automate linting and testing with pre-commit hooks
- **Environment variables**: Use `.env.local` for configuration

```json
// package.json scripts
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "db:push": "drizzle-kit push",
    "db:migrate": "tsx lib/db/setup.ts",
    "db:seed": "tsx lib/db/seed.ts"
  }
}
```

### Automation Best Practices
- **Automate repetitive tasks**: Create scripts for common operations
- **Use migrations**: Never manually update production databases
- **Seed data**: Maintain seed scripts for development/testing
- **Batch operations**: Use bulk operations for efficiency
- **Caching strategies**: Leverage Next.js caching for performance

## Code Quality Standards

### Naming Conventions
- **Variables/Functions**: camelCase (`getUserData`, `isValid`)
- **Components**: PascalCase (`UserProfile`, `DashboardLayout`)
- **Constants**: UPPER_SNAKE_CASE (`API_URL`, `MAX_RETRIES`)
- **Private functions**: Prefix with underscore (`_internal`)
- **Boolean variables**: Use `is`, `has`, `should` prefixes (`isLoading`, `hasAccess`)

### Comments and Documentation
- **Self-documenting code**: Write clear code that doesn't need comments
- **Comment WHY, not WHAT**: Explain reasoning, not obvious actions
- **JSDoc for functions**: Document public APIs and complex functions
- **TODO comments**: Include name and date (`// TODO (JJR, 2025-11-09): Fix edge case`)

```typescript
/**
 * Validates user subscription status and returns available features
 * @param userId - The user's unique identifier
 * @returns Object containing subscription tier and enabled features
 * @throws Error if user not found
 */
export async function getUserFeatures(userId: string) {
  // Implementation
}
```

### Error Handling
- **Always handle errors**: Never ignore try-catch blocks
- **Specific error types**: Create custom error classes when needed
- **User-friendly messages**: Show actionable error messages to users
- **Log errors**: Log errors with context for debugging
- **Graceful degradation**: Provide fallbacks when services fail

```typescript
// Good
try {
  await processPayment(data);
} catch (error) {
  console.error('Payment processing failed:', error);
  return { error: 'Unable to process payment. Please try again.' };
}
```

### Performance Considerations
- **Lazy loading**: Use dynamic imports for code splitting
- **Memoization**: Use React.memo, useMemo, useCallback appropriately
- **Database indexing**: Add indexes for frequently queried fields
- **Image optimization**: Use Next.js Image component
- **Bundle size**: Monitor and minimize bundle size

### Security Best Practices
- **Never commit secrets**: Use environment variables for sensitive data
- **Validate all inputs**: Sanitize and validate user input
- **Authentication checks**: Verify auth in API routes and Server Actions
- **SQL injection prevention**: Use parameterized queries (Drizzle handles this)
- **XSS prevention**: Sanitize user-generated content
- **CSRF protection**: Leverage Next.js built-in protections

```typescript
// Good - Environment variables
const stripeKey = process.env.STRIPE_SECRET_KEY;
if (!stripeKey) {
  throw new Error('Missing STRIPE_SECRET_KEY');
}
```

## Testing Guidelines

### Testing Strategy
- **Unit tests**: Test pure functions and utilities
- **Integration tests**: Test API routes and database operations
- **E2E tests**: Test critical user flows
- **Test edge cases**: Include boundary conditions and error scenarios

### E2E Testing Philosophy (Pragmatic Approach)
- **Focus on revenue-generating flows**: Prioritize Pro tier features, subscription upgrades, and core value delivery
- **Test real APIs**: Use real internal APIs; only mock external services (Stripe, Wikidata, LLM APIs)
- **Pragmatic over exhaustive**: Test critical paths that impact business success, not every edge case
- **Pro tier emphasis**: Prioritize testing Pro user journeys where revenue is generated
- **See**: `tests/e2e/PRAGMATIC_KGAAS_TESTS.md` for detailed testing strategy

### E2E Test Structure
- **Use fixtures**: Leverage `tests/e2e/fixtures/authenticated-user.ts` for authenticated sessions
- **Page objects**: Use page objects in `tests/e2e/pages/` for reusable interactions
- **Helpers**: Centralize common operations in `tests/e2e/helpers/`
- **DRY principles**: Reuse fixtures, page objects, and helpers across tests
- **SOLID principles**: Each test file should focus on a single journey/responsibility

### Playwright Test Agents
- **Healer agent**: Use to fix flaky/failing tests automatically (highest value)
- **Planner agent**: Use to generate test plans for missing coverage areas
- **Generator agent**: Use sparingly; prefer manual implementation aligned with existing patterns
- **Seed test**: Maintain `tests/e2e/seed.spec.ts` for agent exploration and environment setup
- **Alignment**: Generated code must align with existing patterns (fixtures, page objects, real APIs)

### Test Organization
- Colocate tests with source files or in `__tests__` directories
- Use descriptive test names: `it('should create user when valid email provided')`
- Follow AAA pattern: Arrange, Act, Assert
- Mock external dependencies only (Stripe, Wikidata, LLM); use real internal APIs

## Git Workflow

### Commit Messages
- Use conventional commits: `feat:`, `fix:`, `chore:`, `docs:`
- Be descriptive: `feat: add user profile editing`
- Reference issues: `fix: resolve payment webhook issue (#123)`

### Branching
- `main`: Production-ready code
- `feature/*`: New features
- `fix/*`: Bug fixes
- `chore/*`: Maintenance tasks

## API Usage Patterns

### External Service Integration
- **Abstract services**: Create service wrappers in `/lib`
- **Error handling**: Handle API failures gracefully
- **Rate limiting**: Implement rate limiting for external APIs
- **Caching**: Cache API responses when appropriate
- **Retry logic**: Implement exponential backoff for retries

```typescript
// Good - Service abstraction
export class PaymentService {
  async createCheckout(params: CheckoutParams) {
    try {
      return await stripe.checkout.sessions.create(params);
    } catch (error) {
      console.error('Stripe checkout failed:', error);
      throw new PaymentError('Failed to create checkout session');
    }
  }
}
```

## Final Guidelines

1. **Favor simplicity**: Simple solutions over clever ones
2. **Premature optimization is evil**: Optimize only when needed
3. **Write for humans**: Code is read more than written
4. **Consistency matters**: Follow existing patterns in the codebase
5. **Test critical paths**: Ensure core functionality is tested
6. **Document decisions**: Explain complex or non-obvious choices
7. **Refactor regularly**: Improve code incrementally
8. **Review before committing**: Self-review your changes
9. **Use TypeScript fully**: Leverage the type system
10. **Think about scale**: Consider how code will grow

---

**Remember**: These rules exist to maintain code quality, consistency, and maintainability. When in doubt, prioritize readability and simplicity.

